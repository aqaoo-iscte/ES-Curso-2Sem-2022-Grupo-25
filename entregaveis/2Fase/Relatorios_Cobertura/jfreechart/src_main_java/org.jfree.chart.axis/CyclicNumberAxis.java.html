<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>CyclicNumberAxis.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">java (1) (14 May 2022 17:53:42)</a> &gt; <a href="../../index.html" class="el_group">jfreechart</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">org.jfree.chart.axis</a> &gt; <span class="el_source">CyclicNumberAxis.java</span></div><h1>CyclicNumberAxis.java</h1><pre class="source lang-java linenums">/* ===========================================================
 * JFreeChart : a free chart library for the Java(tm) platform
 * ===========================================================
 *
 * (C) Copyright 2000-2022, by David Gilbert and Contributors.
 *
 * Project Info:  http://www.jfree.org/jfreechart/index.html
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 * License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
 * USA.
 *
 * [Oracle and Java are registered trademarks of Oracle and/or its affiliates. 
 * Other names may be trademarks of their respective owners.]
 *
 * ---------------------
 * CyclicNumberAxis.java
 * ---------------------
 * (C) Copyright 2003-2021, by Nicolas Brodu and Contributors.
 *
 * Original Author:  Nicolas Brodu;
 * Contributor(s):   David Gilbert;
 *
 */

package org.jfree.chart.axis;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Stroke;
import java.awt.geom.Line2D;
import java.awt.geom.Rectangle2D;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.text.NumberFormat;
import java.util.List;
import java.util.Objects;

import org.jfree.chart.plot.Plot;
import org.jfree.chart.plot.PlotRenderingInfo;
import org.jfree.chart.text.TextUtils;
import org.jfree.chart.api.RectangleEdge;
import org.jfree.chart.text.TextAnchor;
import org.jfree.chart.internal.PaintUtils;
import org.jfree.chart.internal.Args;
import org.jfree.chart.internal.SerialUtils;
import org.jfree.data.Range;
/**
This class extends NumberAxis and handles cycling.

Traditional representation of data in the range x0..x1
&lt;pre&gt;
|-------------------------|
x0                       x1
&lt;/pre&gt;

Here, the range bounds are at the axis extremities.
With cyclic axis, however, the time is split in
&quot;cycles&quot;, or &quot;time frames&quot;, or the same duration : the period.

A cycle axis cannot by definition handle a larger interval
than the period : &lt;pre&gt;x1 - x0 &amp;gt;= period&lt;/pre&gt;. Thus, at most a full
period can be represented with such an axis.

The cycle bound is the number between x0 and x1 which marks
the beginning of new time frame:
&lt;pre&gt;
|---------------------|----------------------------|
x0                   cb                           x1
&amp;lt;---previous cycle---&amp;gt;&amp;lt;-------current cycle--------&amp;gt;
&lt;/pre&gt;

It is actually a multiple of the period, plus optionally
a start offset: &lt;pre&gt;cb = n * period + offset&lt;/pre&gt;

Thus, by definition, two consecutive cycle bounds
period apart, which is precisely why it is called a
period.

The visual representation of a cyclic axis is like that:
&lt;pre&gt;
|----------------------------|---------------------|
cb                         x1|x0                  cb
&amp;lt;-------current cycle--------&amp;gt;&amp;lt;---previous cycle---&amp;gt;
&lt;/pre&gt;

The cycle bound is at the axis ends, then current
cycle is shown, then the last cycle. When using
dynamic data, the visual effect is the current cycle
erases the last cycle as x grows. Then, the next cycle
bound is reached, and the process starts over, erasing
the previous cycle.

A Cyclic item renderer is provided to do exactly this.

 */
public class CyclicNumberAxis extends NumberAxis {

<span class="fc" id="L115">    private transient CyclicNumberAxisProduct cyclicNumberAxisProduct = new CyclicNumberAxisProduct();</span>

	/** For serialization. */
    static final long serialVersionUID = -7514160997164582554L;

    /** The default axis line stroke. */
<span class="fc" id="L121">    public static Stroke DEFAULT_ADVANCE_LINE_STROKE = new BasicStroke(1.0f);</span>

    /** The default axis line paint. */
<span class="fc" id="L124">    public static final Paint DEFAULT_ADVANCE_LINE_PAINT = Color.GRAY;</span>

    /** The offset. */
    protected double offset;

    /** The period.*/
    protected double period;

    /** ??. */
    protected boolean boundMappedToLastCycle;

    /** A flag that controls whether or not the advance line is visible. */
    protected boolean advanceLineVisible;

    private transient boolean internalMarkerWhenTicksOverlap;
    private transient Tick internalMarkerCycleBoundTick;

    /**
     * Creates a CycleNumberAxis with the given period.
     *
     * @param period  the period.
     */
    public CyclicNumberAxis(double period) {
<span class="nc" id="L147">        this(period, 0.0);</span>
<span class="nc" id="L148">    }</span>

    /**
     * Creates a CycleNumberAxis with the given period and offset.
     *
     * @param period  the period.
     * @param offset  the offset.
     */
    public CyclicNumberAxis(double period, double offset) {
<span class="nc" id="L157">        this(period, offset, null);</span>
<span class="nc" id="L158">    }</span>

    /**
     * Creates a named CycleNumberAxis with the given period.
     *
     * @param period  the period.
     * @param label  the label.
     */
    public CyclicNumberAxis(double period, String label) {
<span class="nc" id="L167">        this(0, period, label);</span>
<span class="nc" id="L168">    }</span>

    /**
     * Creates a named CycleNumberAxis with the given period and offset.
     *
     * @param period  the period.
     * @param offset  the offset.
     * @param label  the label.
     */
    public CyclicNumberAxis(double period, double offset, String label) {
<span class="fc" id="L178">        super(label);</span>
<span class="fc" id="L179">        this.period = period;</span>
<span class="fc" id="L180">        this.offset = offset;</span>
<span class="fc" id="L181">        setFixedAutoRange(period);</span>
<span class="fc" id="L182">        this.advanceLineVisible = true;</span>
<span class="fc" id="L183">        cyclicNumberAxisProduct.setAdvanceLinePaint2(DEFAULT_ADVANCE_LINE_PAINT);</span>
<span class="fc" id="L184">    }</span>

    /**
     * The advance line is the line drawn at the limit of the current cycle,
     * when erasing the previous cycle.
     *
     * @return A boolean.
     */
    public boolean isAdvanceLineVisible() {
<span class="fc" id="L193">        return this.advanceLineVisible;</span>
    }

    /**
     * The advance line is the line drawn at the limit of the current cycle,
     * when erasing the previous cycle.
     *
     * @param visible  the flag.
     */
    public void setAdvanceLineVisible(boolean visible) {
<span class="fc" id="L203">        this.advanceLineVisible = visible;</span>
<span class="fc" id="L204">    }</span>

    /**
     * The advance line is the line drawn at the limit of the current cycle,
     * when erasing the previous cycle.
     *
     * @return The paint (never {@code null}).
     */
    public Paint getAdvanceLinePaint() {
<span class="nc" id="L213">        return this.cyclicNumberAxisProduct.getAdvanceLinePaint();</span>
    }

    /**
     * The advance line is the line drawn at the limit of the current cycle,
     * when erasing the previous cycle.
     *
     * @param paint  the paint ({@code null} not permitted).
     */
    public void setAdvanceLinePaint(Paint paint) {
<span class="fc" id="L223">        cyclicNumberAxisProduct.setAdvanceLinePaint(paint);</span>
<span class="fc" id="L224">    }</span>

    /**
     * The advance line is the line drawn at the limit of the current cycle,
     * when erasing the previous cycle.
     *
     * @return The stroke (never {@code null}).
     */
    public Stroke getAdvanceLineStroke() {
<span class="nc" id="L233">        return this.cyclicNumberAxisProduct.getAdvanceLineStroke();</span>
    }
    /**
     * The advance line is the line drawn at the limit of the current cycle,
     * when erasing the previous cycle.
     *
     * @param stroke  the stroke ({@code null} not permitted).
     */
    public void setAdvanceLineStroke(Stroke stroke) {
<span class="fc" id="L242">        cyclicNumberAxisProduct.setAdvanceLineStroke(stroke);</span>
<span class="fc" id="L243">    }</span>

    /**
     * The cycle bound can be associated either with the current or with the
     * last cycle.  It's up to the user's choice to decide which, as this is
     * just a convention.  By default, the cycle bound is mapped to the current
     * cycle.
     * &lt;br&gt;
     * Note that this has no effect on visual appearance, as the cycle bound is
     * mapped successively for both axis ends. Use this function for correct
     * results in translateValueToJava2D.
     *
     * @return {@code true} if the cycle bound is mapped to the last
     *         cycle, {@code false} if it is bound to the current cycle
     *         (default)
     */
    public boolean isBoundMappedToLastCycle() {
<span class="fc" id="L260">        return this.boundMappedToLastCycle;</span>
    }

    /**
     * The cycle bound can be associated either with the current or with the
     * last cycle.  It's up to the user's choice to decide which, as this is
     * just a convention. By default, the cycle bound is mapped to the current
     * cycle.
     * &lt;br&gt;
     * Note that this has no effect on visual appearance, as the cycle bound is
     * mapped successively for both axis ends. Use this function for correct
     * results in valueToJava2D.
     *
     * @param boundMappedToLastCycle Set it to true to map the cycle bound to
     *        the last cycle.
     */
    public void setBoundMappedToLastCycle(boolean boundMappedToLastCycle) {
<span class="fc" id="L277">        this.boundMappedToLastCycle = boundMappedToLastCycle;</span>
<span class="fc" id="L278">    }</span>

    /**
     * Selects a tick unit when the axis is displayed horizontally.
     *
     * @param g2  the graphics device.
     * @param drawArea  the drawing area.
     * @param dataArea  the data area.
     * @param edge  the side of the rectangle on which the axis is displayed.
     */
    protected void selectHorizontalAutoTickUnit(Graphics2D g2,
            Rectangle2D drawArea, Rectangle2D dataArea, RectangleEdge edge) {

<span class="nc" id="L291">        double tickLabelWidth</span>
<span class="nc" id="L292">            = estimateMaximumTickLabelWidth(g2, getTickUnit());</span>

        // Compute number of labels
<span class="nc" id="L295">        double n = getRange().getLength()</span>
<span class="nc" id="L296">                   * tickLabelWidth / dataArea.getWidth();</span>

<span class="nc" id="L298">        setTickUnit(</span>
<span class="nc" id="L299">                (NumberTickUnit) getStandardTickUnits().getCeilingTickUnit(n),</span>
<span class="nc" id="L300">                false, false);</span>

<span class="nc" id="L302">     }</span>

    /**
     * Selects a tick unit when the axis is displayed vertically.
     *
     * @param g2  the graphics device.
     * @param drawArea  the drawing area.
     * @param dataArea  the data area.
     * @param edge  the side of the rectangle on which the axis is displayed.
     */
    protected void selectVerticalAutoTickUnit(Graphics2D g2,
            Rectangle2D drawArea, Rectangle2D dataArea, RectangleEdge edge) {

<span class="nc" id="L315">        double tickLabelWidth</span>
<span class="nc" id="L316">            = estimateMaximumTickLabelWidth(g2, getTickUnit());</span>

        // Compute number of labels
<span class="nc" id="L319">        double n = getRange().getLength()</span>
<span class="nc" id="L320">                   * tickLabelWidth / dataArea.getHeight();</span>

<span class="nc" id="L322">        setTickUnit(</span>
<span class="nc" id="L323">            (NumberTickUnit) getStandardTickUnits().getCeilingTickUnit(n),</span>
<span class="nc" id="L324">            false, false);</span>
<span class="nc" id="L325">     }</span>

    /**
     * A special Number tick that also hold information about the cycle bound
     * mapping for this tick.  This is especially useful for having a tick at
     * each axis end with the cycle bound value.  See also
     * isBoundMappedToLastCycle()
     */
    protected static class CycleBoundTick extends NumberTick {

        /** Map to last cycle. */
        public boolean mapToLastCycle;

        /**
         * Creates a new tick.
         *
         * @param mapToLastCycle  map to last cycle?
         * @param number  the number.
         * @param label  the label.
         * @param textAnchor  the text anchor.
         * @param rotationAnchor  the rotation anchor.
         * @param angle  the rotation angle.
         */
        public CycleBoundTick(boolean mapToLastCycle, Number number,
                              String label, TextAnchor textAnchor,
                              TextAnchor rotationAnchor, double angle) {
<span class="nc" id="L351">            super(number, label, textAnchor, rotationAnchor, angle);</span>
<span class="nc" id="L352">            this.mapToLastCycle = mapToLastCycle;</span>
<span class="nc" id="L353">        }</span>
    }

    /**
     * Calculates the anchor point for a tick.
     *
     * @param tick  the tick.
     * @param cursor  the cursor.
     * @param dataArea  the data area.
     * @param edge  the side on which the axis is displayed.
     *
     * @return The anchor point.
     */
    @Override
    protected float[] calculateAnchorPoint(ValueTick tick, double cursor,
            Rectangle2D dataArea, RectangleEdge edge) {
<span class="nc bnc" id="L369" title="All 2 branches missed.">        if (tick instanceof CycleBoundTick) {</span>
<span class="nc" id="L370">            boolean mapsav = this.boundMappedToLastCycle;</span>
<span class="nc" id="L371">            this.boundMappedToLastCycle</span>
<span class="nc" id="L372">                = ((CycleBoundTick) tick).mapToLastCycle;</span>
<span class="nc" id="L373">            float[] ret = super.calculateAnchorPoint(</span>
<span class="nc" id="L374">                tick, cursor, dataArea, edge</span>
            );
<span class="nc" id="L376">            this.boundMappedToLastCycle = mapsav;</span>
<span class="nc" id="L377">            return ret;</span>
        }
<span class="nc" id="L379">        return super.calculateAnchorPoint(tick, cursor, dataArea, edge);</span>
    }



    /**
     * Builds a list of ticks for the axis.  This method is called when the
     * axis is at the top or bottom of the chart (so the axis is &quot;horizontal&quot;).
     *
     * @param g2  the graphics device.
     * @param dataArea  the data area.
     * @param edge  the edge.
     *
     * @return A list of ticks.
     */
    @Override
    protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea,
            RectangleEdge edge) {

<span class="nc" id="L398">        List result = new java.util.ArrayList();</span>

<span class="nc" id="L400">        Font tickLabelFont = getTickLabelFont();</span>
<span class="nc" id="L401">        g2.setFont(tickLabelFont);</span>

<span class="nc bnc" id="L403" title="All 2 branches missed.">        if (isAutoTickUnitSelection()) {</span>
<span class="nc" id="L404">            selectAutoTickUnit(g2, dataArea, edge);</span>
        }

<span class="nc" id="L407">        double unit = getTickUnit().getSize();</span>
<span class="nc" id="L408">        double cycleBound = getCycleBound();</span>
<span class="nc" id="L409">        double currentTickValue = Math.ceil(cycleBound / unit) * unit;</span>
<span class="nc" id="L410">        double upperValue = getRange().getUpperBound();</span>
<span class="nc" id="L411">        boolean cycled = false;</span>

<span class="nc" id="L413">        boolean boundMapping = this.boundMappedToLastCycle;</span>
<span class="nc" id="L414">        this.boundMappedToLastCycle = false;</span>

<span class="nc" id="L416">        CycleBoundTick lastTick = null;</span>
<span class="nc" id="L417">        float lastX = 0.0f;</span>

<span class="nc bnc" id="L419" title="All 2 branches missed.">        if (upperValue == cycleBound) {</span>
<span class="nc" id="L420">            currentTickValue = calculateLowestVisibleTickValue();</span>
<span class="nc" id="L421">            cycled = true;</span>
<span class="nc" id="L422">            this.boundMappedToLastCycle = true;</span>
        }

<span class="nc bnc" id="L425" title="All 2 branches missed.">        while (currentTickValue &lt;= upperValue) {</span>

            // Cycle when necessary
<span class="nc" id="L428">            boolean cyclenow = false;</span>
<span class="nc bnc" id="L429" title="All 4 branches missed.">            if ((currentTickValue + unit &gt; upperValue) &amp;&amp; !cycled) {</span>
<span class="nc" id="L430">                cyclenow = true;</span>
            }

<span class="nc" id="L433">            double xx = valueToJava2D(currentTickValue, dataArea, edge);</span>
            String tickLabel;
<span class="nc" id="L435">            NumberFormat formatter = getNumberFormatOverride();</span>
<span class="nc bnc" id="L436" title="All 2 branches missed.">            if (formatter != null) {</span>
<span class="nc" id="L437">                tickLabel = formatter.format(currentTickValue);</span>
<span class="nc" id="L438">            }</span>
            else {
<span class="nc" id="L440">                tickLabel = getTickUnit().valueToString(currentTickValue);</span>
            }
<span class="nc" id="L442">            float x = (float) xx;</span>
            TextAnchor anchor;
            TextAnchor rotationAnchor;
<span class="nc" id="L445">            double angle = 0.0;</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">            if (isVerticalTickLabels()) {</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">                if (edge == RectangleEdge.TOP) {</span>
<span class="nc" id="L448">                    angle = Math.PI / 2.0;</span>
<span class="nc" id="L449">                }</span>
                else {
<span class="nc" id="L451">                    angle = -Math.PI / 2.0;</span>
                }
<span class="nc" id="L453">                anchor = TextAnchor.CENTER_RIGHT;</span>
                // If tick overlap when cycling, update last tick too
<span class="nc bnc" id="L455" title="All 4 branches missed.">                if ((lastTick != null) &amp;&amp; (lastX == x)</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">                        &amp;&amp; (currentTickValue != cycleBound)) {</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">                    anchor = isInverted()</span>
<span class="nc" id="L458">                        ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT;</span>
<span class="nc" id="L459">                    result.remove(result.size() - 1);</span>
<span class="nc" id="L460">                    result.add(new CycleBoundTick(</span>
<span class="nc" id="L461">                        this.boundMappedToLastCycle, lastTick.getNumber(),</span>
<span class="nc" id="L462">                        lastTick.getText(), anchor, anchor,</span>
<span class="nc" id="L463">                        lastTick.getAngle())</span>
                    );
<span class="nc" id="L465">                    this.internalMarkerWhenTicksOverlap = true;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">                    anchor = isInverted()</span>
<span class="nc" id="L467">                        ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT;</span>
                }
<span class="nc" id="L469">                rotationAnchor = anchor;</span>
<span class="nc" id="L470">            }</span>
            else {
<span class="nc bnc" id="L472" title="All 2 branches missed.">                if (edge == RectangleEdge.TOP) {</span>
<span class="nc" id="L473">                    anchor = TextAnchor.BOTTOM_CENTER;</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">                    if ((lastTick != null) &amp;&amp; (lastX == x)</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">                            &amp;&amp; (currentTickValue != cycleBound)) {</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">                        anchor = isInverted()</span>
<span class="nc" id="L477">                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;</span>
<span class="nc" id="L478">                        result.remove(result.size() - 1);</span>
<span class="nc" id="L479">                        result.add(new CycleBoundTick(</span>
<span class="nc" id="L480">                            this.boundMappedToLastCycle, lastTick.getNumber(),</span>
<span class="nc" id="L481">                            lastTick.getText(), anchor, anchor,</span>
<span class="nc" id="L482">                            lastTick.getAngle())</span>
                        );
<span class="nc" id="L484">                        this.internalMarkerWhenTicksOverlap = true;</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">                        anchor = isInverted()</span>
<span class="nc" id="L486">                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;</span>
                    }
<span class="nc" id="L488">                    rotationAnchor = anchor;</span>
<span class="nc" id="L489">                }</span>
                else {
<span class="nc" id="L491">                    anchor = TextAnchor.TOP_CENTER;</span>
<span class="nc bnc" id="L492" title="All 4 branches missed.">                    if ((lastTick != null) &amp;&amp; (lastX == x)</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">                            &amp;&amp; (currentTickValue != cycleBound)) {</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">                        anchor = isInverted()</span>
<span class="nc" id="L495">                            ? TextAnchor.TOP_LEFT : TextAnchor.TOP_RIGHT;</span>
<span class="nc" id="L496">                        result.remove(result.size() - 1);</span>
<span class="nc" id="L497">                        result.add(new CycleBoundTick(</span>
<span class="nc" id="L498">                            this.boundMappedToLastCycle, lastTick.getNumber(),</span>
<span class="nc" id="L499">                            lastTick.getText(), anchor, anchor,</span>
<span class="nc" id="L500">                            lastTick.getAngle())</span>
                        );
<span class="nc" id="L502">                        this.internalMarkerWhenTicksOverlap = true;</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">                        anchor = isInverted()</span>
<span class="nc" id="L504">                            ? TextAnchor.TOP_RIGHT : TextAnchor.TOP_LEFT;</span>
                    }
<span class="nc" id="L506">                    rotationAnchor = anchor;</span>
                }
            }

<span class="nc" id="L510">            CycleBoundTick tick = new CycleBoundTick(this.boundMappedToLastCycle, </span>
<span class="nc" id="L511">                    currentTickValue, tickLabel, anchor, rotationAnchor, angle);</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">            if (currentTickValue == cycleBound) {</span>
<span class="nc" id="L513">                this.internalMarkerCycleBoundTick = tick;</span>
            }
<span class="nc" id="L515">            result.add(tick);</span>
<span class="nc" id="L516">            lastTick = tick;</span>
<span class="nc" id="L517">            lastX = x;</span>

<span class="nc" id="L519">            currentTickValue += unit;</span>

<span class="nc bnc" id="L521" title="All 2 branches missed.">            if (cyclenow) {</span>
<span class="nc" id="L522">                currentTickValue = calculateLowestVisibleTickValue();</span>
<span class="nc" id="L523">                upperValue = cycleBound;</span>
<span class="nc" id="L524">                cycled = true;</span>
<span class="nc" id="L525">                this.boundMappedToLastCycle = true;</span>
            }

        }
<span class="nc" id="L529">        this.boundMappedToLastCycle = boundMapping;</span>
<span class="nc" id="L530">        return result;</span>

    }

    /**
     * Builds a list of ticks for the axis.  This method is called when the
     * axis is at the left or right of the chart (so the axis is &quot;vertical&quot;).
     *
     * @param g2  the graphics device.
     * @param dataArea  the data area.
     * @param edge  the edge.
     *
     * @return A list of ticks.
     */
    protected List refreshVerticalTicks(Graphics2D g2, Rectangle2D dataArea,
            RectangleEdge edge) {

<span class="nc" id="L547">        List result = new java.util.ArrayList();</span>
<span class="nc" id="L548">        result.clear();</span>

<span class="nc" id="L550">        Font tickLabelFont = getTickLabelFont();</span>
<span class="nc" id="L551">        g2.setFont(tickLabelFont);</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">        if (isAutoTickUnitSelection()) {</span>
<span class="nc" id="L553">            selectAutoTickUnit(g2, dataArea, edge);</span>
        }

<span class="nc" id="L556">        double unit = getTickUnit().getSize();</span>
<span class="nc" id="L557">        double cycleBound = getCycleBound();</span>
<span class="nc" id="L558">        double currentTickValue = Math.ceil(cycleBound / unit) * unit;</span>
<span class="nc" id="L559">        double upperValue = getRange().getUpperBound();</span>
<span class="nc" id="L560">        boolean cycled = false;</span>

<span class="nc" id="L562">        boolean boundMapping = this.boundMappedToLastCycle;</span>
<span class="nc" id="L563">        this.boundMappedToLastCycle = true;</span>

<span class="nc" id="L565">        NumberTick lastTick = null;</span>
<span class="nc" id="L566">        float lastY = 0.0f;</span>

<span class="nc bnc" id="L568" title="All 2 branches missed.">        if (upperValue == cycleBound) {</span>
<span class="nc" id="L569">            currentTickValue = calculateLowestVisibleTickValue();</span>
<span class="nc" id="L570">            cycled = true;</span>
<span class="nc" id="L571">            this.boundMappedToLastCycle = true;</span>
        }

<span class="nc bnc" id="L574" title="All 2 branches missed.">        while (currentTickValue &lt;= upperValue) {</span>

            // Cycle when necessary
<span class="nc" id="L577">            boolean cyclenow = false;</span>
<span class="nc bnc" id="L578" title="All 4 branches missed.">            if ((currentTickValue + unit &gt; upperValue) &amp;&amp; !cycled) {</span>
<span class="nc" id="L579">                cyclenow = true;</span>
            }

<span class="nc" id="L582">            double yy = valueToJava2D(currentTickValue, dataArea, edge);</span>
<span class="nc" id="L583">            String tickLabel = tickLabel(currentTickValue);</span>
<span class="nc" id="L584">			float y = (float) yy;</span>
            TextAnchor anchor;
            TextAnchor rotationAnchor;
<span class="nc" id="L587">            double angle = 0.0;</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">            if (isVerticalTickLabels()) {</span>

<span class="nc bnc" id="L590" title="All 2 branches missed.">                if (edge == RectangleEdge.LEFT) {</span>
<span class="nc" id="L591">                    anchor = TextAnchor.BOTTOM_CENTER;</span>
<span class="nc bnc" id="L592" title="All 4 branches missed.">                    if ((lastTick != null) &amp;&amp; (lastY == y)</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">                            &amp;&amp; (currentTickValue != cycleBound)) {</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">                        anchor = isInverted()</span>
<span class="nc" id="L595">                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;</span>
<span class="nc" id="L596">                        result.remove(result.size() - 1);</span>
<span class="nc" id="L597">                        result.add(new CycleBoundTick(</span>
<span class="nc" id="L598">                            this.boundMappedToLastCycle, lastTick.getNumber(),</span>
<span class="nc" id="L599">                            lastTick.getText(), anchor, anchor,</span>
<span class="nc" id="L600">                            lastTick.getAngle())</span>
                        );
<span class="nc" id="L602">                        this.internalMarkerWhenTicksOverlap = true;</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">                        anchor = isInverted()</span>
<span class="nc" id="L604">                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;</span>
                    }
<span class="nc" id="L606">                    rotationAnchor = anchor;</span>
<span class="nc" id="L607">                    angle = -Math.PI / 2.0;</span>
<span class="nc" id="L608">                }</span>
                else {
<span class="nc" id="L610">                    anchor = TextAnchor.BOTTOM_CENTER;</span>
<span class="nc bnc" id="L611" title="All 4 branches missed.">                    if ((lastTick != null) &amp;&amp; (lastY == y)</span>
<span class="nc bnc" id="L612" title="All 2 branches missed.">                            &amp;&amp; (currentTickValue != cycleBound)) {</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">                        anchor = isInverted()</span>
<span class="nc" id="L614">                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.BOTTOM_LEFT;</span>
<span class="nc" id="L615">                        result.remove(result.size() - 1);</span>
<span class="nc" id="L616">                        result.add(new CycleBoundTick(</span>
<span class="nc" id="L617">                            this.boundMappedToLastCycle, lastTick.getNumber(),</span>
<span class="nc" id="L618">                            lastTick.getText(), anchor, anchor,</span>
<span class="nc" id="L619">                            lastTick.getAngle())</span>
                        );
<span class="nc" id="L621">                        this.internalMarkerWhenTicksOverlap = true;</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">                        anchor = isInverted()</span>
<span class="nc" id="L623">                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.BOTTOM_RIGHT;</span>
                    }
<span class="nc" id="L625">                    rotationAnchor = anchor;</span>
<span class="nc" id="L626">                    angle = Math.PI / 2.0;</span>
                }
<span class="nc" id="L628">            }</span>
            else {
<span class="nc bnc" id="L630" title="All 2 branches missed.">                if (edge == RectangleEdge.LEFT) {</span>
<span class="nc" id="L631">                    anchor = TextAnchor.CENTER_RIGHT;</span>
<span class="nc bnc" id="L632" title="All 4 branches missed.">                    if ((lastTick != null) &amp;&amp; (lastY == y)</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">                            &amp;&amp; (currentTickValue != cycleBound)) {</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">                        anchor = isInverted()</span>
<span class="nc" id="L635">                            ? TextAnchor.BOTTOM_RIGHT : TextAnchor.TOP_RIGHT;</span>
<span class="nc" id="L636">                        result.remove(result.size() - 1);</span>
<span class="nc" id="L637">                        result.add(new CycleBoundTick(</span>
<span class="nc" id="L638">                            this.boundMappedToLastCycle, lastTick.getNumber(),</span>
<span class="nc" id="L639">                            lastTick.getText(), anchor, anchor,</span>
<span class="nc" id="L640">                            lastTick.getAngle())</span>
                        );
<span class="nc" id="L642">                        this.internalMarkerWhenTicksOverlap = true;</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">                        anchor = isInverted()</span>
<span class="nc" id="L644">                            ? TextAnchor.TOP_RIGHT : TextAnchor.BOTTOM_RIGHT;</span>
                    }
<span class="nc" id="L646">                    rotationAnchor = anchor;</span>
<span class="nc" id="L647">                }</span>
                else {
<span class="nc" id="L649">                    anchor = TextAnchor.CENTER_LEFT;</span>
<span class="nc bnc" id="L650" title="All 4 branches missed.">                    if ((lastTick != null) &amp;&amp; (lastY == y)</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">                            &amp;&amp; (currentTickValue != cycleBound)) {</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">                        anchor = isInverted()</span>
<span class="nc" id="L653">                            ? TextAnchor.BOTTOM_LEFT : TextAnchor.TOP_LEFT;</span>
<span class="nc" id="L654">                        result.remove(result.size() - 1);</span>
<span class="nc" id="L655">                        result.add(new CycleBoundTick(</span>
<span class="nc" id="L656">                            this.boundMappedToLastCycle, lastTick.getNumber(),</span>
<span class="nc" id="L657">                            lastTick.getText(), anchor, anchor,</span>
<span class="nc" id="L658">                            lastTick.getAngle())</span>
                        );
<span class="nc" id="L660">                        this.internalMarkerWhenTicksOverlap = true;</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                        anchor = isInverted()</span>
<span class="nc" id="L662">                            ? TextAnchor.TOP_LEFT : TextAnchor.BOTTOM_LEFT;</span>
                    }
<span class="nc" id="L664">                    rotationAnchor = anchor;</span>
                }
            }

<span class="nc" id="L668">            CycleBoundTick tick = new CycleBoundTick(this.boundMappedToLastCycle, </span>
<span class="nc" id="L669">                    currentTickValue, tickLabel, anchor, rotationAnchor, angle);</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">            if (currentTickValue == cycleBound) {</span>
<span class="nc" id="L671">                this.internalMarkerCycleBoundTick = tick;</span>
            }
<span class="nc" id="L673">            result.add(tick);</span>
<span class="nc" id="L674">            lastTick = tick;</span>
<span class="nc" id="L675">            lastY = y;</span>

<span class="nc bnc" id="L677" title="All 2 branches missed.">            if (currentTickValue == cycleBound) {</span>
<span class="nc" id="L678">                this.internalMarkerCycleBoundTick = tick;</span>
            }

<span class="nc" id="L681">            currentTickValue += unit;</span>

<span class="nc bnc" id="L683" title="All 2 branches missed.">            if (cyclenow) {</span>
<span class="nc" id="L684">                currentTickValue = calculateLowestVisibleTickValue();</span>
<span class="nc" id="L685">                upperValue = cycleBound;</span>
<span class="nc" id="L686">                cycled = true;</span>
<span class="nc" id="L687">                this.boundMappedToLastCycle = false;</span>
            }

        }
<span class="nc" id="L691">        this.boundMappedToLastCycle = boundMapping;</span>
<span class="nc" id="L692">        return result;</span>
    }

	private String tickLabel(double currentTickValue) {
		String tickLabel;
<span class="nc" id="L697">		NumberFormat formatter = getNumberFormatOverride();</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">		if (formatter != null) {</span>
<span class="nc" id="L699">			tickLabel = formatter.format(currentTickValue);</span>
<span class="nc" id="L700">		} else {</span>
<span class="nc" id="L701">			tickLabel = getTickUnit().valueToString(currentTickValue);</span>
		}
<span class="nc" id="L703">		return tickLabel;</span>
	}

    /**
     * Converts a coordinate from Java 2D space to data space.
     *
     * @param java2DValue  the coordinate in Java2D space.
     * @param dataArea  the data area.
     * @param edge  the edge.
     *
     * @return The data value.
     */
    @Override
    public double java2DToValue(double java2DValue, Rectangle2D dataArea,
            RectangleEdge edge) {
<span class="nc" id="L718">        Range range = getRange();</span>

<span class="nc" id="L720">        double vmax = range.getUpperBound();</span>
<span class="nc" id="L721">        double vp = getCycleBound();</span>

<span class="nc" id="L723">        double jmin = 0.0;</span>
<span class="nc" id="L724">        double jmax = 0.0;</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">        if (RectangleEdge.isTopOrBottom(edge)) {</span>
<span class="nc" id="L726">            jmin = dataArea.getMinX();</span>
<span class="nc" id="L727">            jmax = dataArea.getMaxX();</span>
<span class="nc" id="L728">        }</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">        else if (RectangleEdge.isLeftOrRight(edge)) {</span>
<span class="nc" id="L730">            jmin = dataArea.getMaxY();</span>
<span class="nc" id="L731">            jmax = dataArea.getMinY();</span>
        }

<span class="nc bnc" id="L734" title="All 2 branches missed.">        if (isInverted()) {</span>
<span class="nc" id="L735">            double jbreak = jmax - (vmax - vp) * (jmax - jmin) / this.period;</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">            if (java2DValue &gt;= jbreak) {</span>
<span class="nc" id="L737">                return vp + (jmax - java2DValue) * this.period / (jmax - jmin);</span>
            }
            else {
<span class="nc" id="L740">                return vp - (java2DValue - jmin) * this.period / (jmax - jmin);</span>
            }
        }
        else {
<span class="nc" id="L744">            double jbreak = (vmax - vp) * (jmax - jmin) / this.period + jmin;</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">            if (java2DValue &lt;= jbreak) {</span>
<span class="nc" id="L746">                return vp + (java2DValue - jmin) * this.period / (jmax - jmin);</span>
            }
            else {
<span class="nc" id="L749">                return vp - (jmax - java2DValue) * this.period / (jmax - jmin);</span>
            }
        }
    }

    /**
     * Translates a value from data space to Java 2D space.
     *
     * @param value  the data value.
     * @param dataArea  the data area.
     * @param edge  the edge.
     *
     * @return The Java 2D value.
     */
    @Override
    public double valueToJava2D(double value, Rectangle2D dataArea,
            RectangleEdge edge) {
<span class="nc" id="L766">        Range range = getRange();</span>

<span class="nc" id="L768">        double vmin = range.getLowerBound();</span>
<span class="nc" id="L769">        double vmax = range.getUpperBound();</span>
<span class="nc" id="L770">        double vp = getCycleBound();</span>

<span class="nc bnc" id="L772" title="All 4 branches missed.">        if ((value &lt; vmin) || (value &gt; vmax)) {</span>
<span class="nc" id="L773">            return Double.NaN;</span>
        }


<span class="nc" id="L777">        double jmin = 0.0;</span>
<span class="nc" id="L778">        double jmax = 0.0;</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">        if (RectangleEdge.isTopOrBottom(edge)) {</span>
<span class="nc" id="L780">            jmin = dataArea.getMinX();</span>
<span class="nc" id="L781">            jmax = dataArea.getMaxX();</span>
<span class="nc" id="L782">        }</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">        else if (RectangleEdge.isLeftOrRight(edge)) {</span>
<span class="nc" id="L784">            jmax = dataArea.getMinY();</span>
<span class="nc" id="L785">            jmin = dataArea.getMaxY();</span>
        }

<span class="nc bnc" id="L788" title="All 2 branches missed.">        if (isInverted()) {</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">            if (value == vp) {</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">                return this.boundMappedToLastCycle ? jmin : jmax;</span>
            }
<span class="nc bnc" id="L792" title="All 2 branches missed.">            else if (value &gt; vp) {</span>
<span class="nc" id="L793">                return jmax - (value - vp) * (jmax - jmin) / this.period;</span>
            }
            else {
<span class="nc" id="L796">                return jmin + (vp - value) * (jmax - jmin) / this.period;</span>
            }
        }
        else {
<span class="nc bnc" id="L800" title="All 2 branches missed.">            if (value == vp) {</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">                return this.boundMappedToLastCycle ? jmax : jmin;</span>
            }
<span class="nc bnc" id="L803" title="All 2 branches missed.">            else if (value &gt;= vp) {</span>
<span class="nc" id="L804">                return jmin + (value - vp) * (jmax - jmin) / this.period;</span>
            }
            else {
<span class="nc" id="L807">                return jmax - (vp - value) * (jmax - jmin) / this.period;</span>
            }
        }
    }

    /**
     * Centers the range about the given value.
     *
     * @param value  the data value.
     */
    @Override
    public void centerRange(double value) {
<span class="nc" id="L819">        setRange(value - this.period / 2.0, value + this.period / 2.0);</span>
<span class="nc" id="L820">    }</span>

    /**
     * This function is nearly useless since the auto range is fixed for this
     * class to the period.  The period is extended if necessary to fit the
     * minimum size.
     *
     * @param size  the size.
     * @param notify  notify?
     *
     * @see org.jfree.chart.axis.ValueAxis#setAutoRangeMinimumSize(double,
     *      boolean)
     */
    @Override
    public void setAutoRangeMinimumSize(double size, boolean notify) {
<span class="nc bnc" id="L835" title="All 2 branches missed.">        if (size &gt; this.period) {</span>
<span class="nc" id="L836">            this.period = size;</span>
        }
<span class="nc" id="L838">        super.setAutoRangeMinimumSize(size, notify);</span>
<span class="nc" id="L839">    }</span>

    /**
     * The auto range is fixed for this class to the period by default.
     * This function will thus set a new period.
     *
     * @param length  the length.
     *
     * @see org.jfree.chart.axis.ValueAxis#setFixedAutoRange(double)
     */
    @Override
    public void setFixedAutoRange(double length) {
<span class="fc" id="L851">        this.period = length;</span>
<span class="fc" id="L852">        super.setFixedAutoRange(length);</span>
<span class="fc" id="L853">    }</span>

    /**
     * Sets a new axis range. The period is extended to fit the range size, if
     * necessary.
     *
     * @param range  the range.
     * @param turnOffAutoRange  switch off the auto range.
     * @param notify notify?
     *
     * @see org.jfree.chart.axis.ValueAxis#setRange(Range, boolean, boolean)
     */
    @Override
    public void setRange(Range range, boolean turnOffAutoRange,
            boolean notify) {
<span class="nc" id="L868">        double size = range.getUpperBound() - range.getLowerBound();</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">        if (size &gt; this.period) {</span>
<span class="nc" id="L870">            this.period = size;</span>
        }
<span class="nc" id="L872">        super.setRange(range, turnOffAutoRange, notify);</span>
<span class="nc" id="L873">    }</span>

    /**
     * The cycle bound is defined as the higest value x such that
     * &quot;offset + period * i = x&quot;, with i and integer and x &amp;lt;
     * range.getUpperBound() This is the value which is at both ends of the
     * axis :  x...up|low...x
     * The values from x to up are the valued in the current cycle.
     * The values from low to x are the valued in the previous cycle.
     *
     * @return The cycle bound.
     */
    public double getCycleBound() {
<span class="nc" id="L886">        return Math.floor(</span>
<span class="nc" id="L887">            (getRange().getUpperBound() - this.offset) / this.period</span>
<span class="nc" id="L888">        ) * this.period + this.offset;</span>
    }

    /**
     * The cycle bound is a multiple of the period, plus optionally a start
     * offset.
     * &lt;pre&gt;cb = n * period + offset&lt;/pre&gt;
     *
     * @return The current offset.
     *
     * @see #getCycleBound()
     */
    public double getOffset() {
<span class="nc" id="L901">        return this.offset;</span>
    }

    /**
     * The cycle bound is a multiple of the period, plus optionally a start
     * offset.
     * &lt;pre&gt;cb = n * period + offset&lt;/pre&gt;
     *
     * @param offset The offset to set.
     *
     * @see #getCycleBound()
     */
    public void setOffset(double offset) {
<span class="fc" id="L914">        this.offset = offset;</span>
<span class="fc" id="L915">    }</span>

    /**
     * The cycle bound is a multiple of the period, plus optionally a start
     * offset.
     * &lt;pre&gt;cb = n * period + offset&lt;/pre&gt;
     *
     * @return The current period.
     *
     * @see #getCycleBound()
     */
    public double getPeriod() {
<span class="nc" id="L927">        return this.period;</span>
    }

    /**
     * The cycle bound is a multiple of the period, plus optionally a start
     * offset.
     * &lt;pre&gt;cb = n * period + offset&lt;/pre&gt;
     *
     * @param period The period to set.
     *
     * @see #getCycleBound()
     */
    public void setPeriod(double period) {
<span class="fc" id="L940">        this.period = period;</span>
<span class="fc" id="L941">    }</span>

    /**
     * Draws the tick marks and labels.
     *
     * @param g2  the graphics device.
     * @param cursor  the cursor.
     * @param plotArea  the plot area.
     * @param dataArea  the area inside the axes.
     * @param edge  the side on which the axis is displayed.
     *
     * @return The axis state.
     */
    @Override
    protected AxisState drawTickMarksAndLabels(Graphics2D g2, double cursor,
            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge) {
<span class="nc" id="L957">        this.internalMarkerWhenTicksOverlap = false;</span>
<span class="nc" id="L958">        AxisState ret = super.drawTickMarksAndLabels(g2, cursor, plotArea,</span>
<span class="nc" id="L959">                dataArea, edge);</span>

        // continue and separate the labels only if necessary
<span class="nc bnc" id="L962" title="All 2 branches missed.">        if (!this.internalMarkerWhenTicksOverlap) {</span>
<span class="nc" id="L963">            return ret;</span>
        }

<span class="nc" id="L966">        double ol = ol(g2);</span>
<span class="nc" id="L967">		double il = 0;</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">        if (isTickMarksVisible()) {</span>
<span class="nc" id="L969">            float xx = (float) valueToJava2D(getRange().getUpperBound(),</span>
<span class="nc" id="L970">                    dataArea, edge);</span>
<span class="nc" id="L971">            Line2D mark = null;</span>
<span class="nc" id="L972">            g2.setStroke(getTickMarkStroke());</span>
<span class="nc" id="L973">            g2.setPaint(getTickMarkPaint());</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">            if (edge == RectangleEdge.LEFT) {</span>
<span class="nc" id="L975">                mark = new Line2D.Double(cursor - ol, xx, cursor + il, xx);</span>
<span class="nc" id="L976">            }</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">            else if (edge == RectangleEdge.RIGHT) {</span>
<span class="nc" id="L978">                mark = new Line2D.Double(cursor + ol, xx, cursor - il, xx);</span>
<span class="nc" id="L979">            }</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">            else if (edge == RectangleEdge.TOP) {</span>
<span class="nc" id="L981">                mark = new Line2D.Double(xx, cursor - ol, xx, cursor + il);</span>
<span class="nc" id="L982">            }</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">            else if (edge == RectangleEdge.BOTTOM) {</span>
<span class="nc" id="L984">                mark = new Line2D.Double(xx, cursor + ol, xx, cursor - il);</span>
            }
<span class="nc" id="L986">            g2.draw(mark);</span>
        }
<span class="nc" id="L988">        return ret;</span>
    }

	private double ol(Graphics2D g2) {
		double ol;
<span class="nc" id="L993">		FontMetrics fm = g2.getFontMetrics(getTickLabelFont());</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">		if (isVerticalTickLabels()) {</span>
<span class="nc" id="L995">			ol = fm.getMaxAdvance();</span>
<span class="nc" id="L996">		} else {</span>
<span class="nc" id="L997">			ol = fm.getHeight();</span>
		}
<span class="nc" id="L999">		return ol;</span>
	}

    /**
     * Draws the axis.
     *
     * @param g2  the graphics device ({@code null} not permitted).
     * @param cursor  the cursor position.
     * @param plotArea  the plot area ({@code null} not permitted).
     * @param dataArea  the data area ({@code null} not permitted).
     * @param edge  the edge ({@code null} not permitted).
     * @param plotState  collects information about the plot
     *                   ({@code null} permitted).
     *
     * @return The axis state (never {@code null}).
     */
    @Override
    public AxisState draw(Graphics2D g2, double cursor, Rectangle2D plotArea,
            Rectangle2D dataArea, RectangleEdge edge, PlotRenderingInfo plotState) {

<span class="nc" id="L1019">        AxisState ret = super.draw(g2, cursor, plotArea, dataArea, edge, </span>
<span class="nc" id="L1020">                plotState);</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">        if (isAdvanceLineVisible()) {</span>
<span class="nc" id="L1022">            double xx = valueToJava2D(getRange().getUpperBound(), dataArea, </span>
<span class="nc" id="L1023">                    edge);</span>
<span class="nc" id="L1024">            Line2D mark = null;</span>
<span class="nc" id="L1025">            g2.setStroke(getAdvanceLineStroke());</span>
<span class="nc" id="L1026">            g2.setPaint(getAdvanceLinePaint());</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">            if (edge == RectangleEdge.LEFT) {</span>
<span class="nc" id="L1028">                mark = new Line2D.Double(cursor, xx, cursor </span>
<span class="nc" id="L1029">                        + dataArea.getWidth(), xx);</span>
<span class="nc" id="L1030">            }</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">            else if (edge == RectangleEdge.RIGHT) {</span>
<span class="nc" id="L1032">                mark = new Line2D.Double(cursor - dataArea.getWidth(), xx, </span>
<span class="nc" id="L1033">                        cursor, xx);</span>
<span class="nc" id="L1034">            }</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">            else if (edge == RectangleEdge.TOP) {</span>
<span class="nc" id="L1036">                mark = new Line2D.Double(xx, cursor + dataArea.getHeight(), xx, </span>
<span class="nc" id="L1037">                        cursor);</span>
<span class="nc" id="L1038">            }</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">            else if (edge == RectangleEdge.BOTTOM) {</span>
<span class="nc" id="L1040">                mark = new Line2D.Double(xx, cursor, xx, </span>
<span class="nc" id="L1041">                        cursor - dataArea.getHeight());</span>
            }
<span class="nc" id="L1043">            g2.draw(mark);</span>
        }
<span class="nc" id="L1045">        return ret;</span>
    }

    /**
     * Reserve some space on each axis side because we draw a centered label at
     * each extremity.
     *
     * @param g2  the graphics device.
     * @param plot  the plot.
     * @param plotArea  the plot area.
     * @param edge  the edge.
     * @param space  the space already reserved.
     *
     * @return The reserved space.
     */
    @Override
    public AxisSpace reserveSpace(Graphics2D g2, Plot plot,
            Rectangle2D plotArea, RectangleEdge edge, AxisSpace space) {

<span class="nc" id="L1064">        this.internalMarkerCycleBoundTick = null;</span>
<span class="nc" id="L1065">        AxisSpace ret = super.reserveSpace(g2, plot, plotArea, edge, space);</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">        if (this.internalMarkerCycleBoundTick == null) {</span>
<span class="nc" id="L1067">            return ret;</span>
        }

<span class="nc" id="L1070">        FontMetrics fm = g2.getFontMetrics(getTickLabelFont());</span>
<span class="nc" id="L1071">        Rectangle2D r = TextUtils.getTextBounds(</span>
<span class="nc" id="L1072">            this.internalMarkerCycleBoundTick.getText(), g2, fm</span>
        );

<span class="nc bnc" id="L1075" title="All 2 branches missed.">        if (RectangleEdge.isTopOrBottom(edge)) {</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">            if (isVerticalTickLabels()) {</span>
<span class="nc" id="L1077">                space.add(r.getHeight() / 2, RectangleEdge.RIGHT);</span>
<span class="nc" id="L1078">            }</span>
            else {
<span class="nc" id="L1080">                space.add(r.getWidth() / 2, RectangleEdge.RIGHT);</span>
            }
<span class="nc" id="L1082">        }</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">        else if (RectangleEdge.isLeftOrRight(edge)) {</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">            if (isVerticalTickLabels()) {</span>
<span class="nc" id="L1085">                space.add(r.getWidth() / 2, RectangleEdge.TOP);</span>
<span class="nc" id="L1086">            }</span>
            else {
<span class="nc" id="L1088">                space.add(r.getHeight() / 2, RectangleEdge.TOP);</span>
            }
        }

<span class="nc" id="L1092">        return ret;</span>

    }

    /**
     * Provides serialization support.
     *
     * @param stream  the output stream.
     *
     * @throws IOException  if there is an I/O error.
     */
    private void writeObject(ObjectOutputStream stream) throws IOException {
<span class="fc" id="L1104">        stream.defaultWriteObject();</span>
<span class="fc" id="L1105">		stream.writeObject(this.cyclicNumberAxisProduct);</span>
<span class="fc" id="L1106">        SerialUtils.writePaint(this.cyclicNumberAxisProduct.getAdvanceLinePaint(), stream);</span>
<span class="fc" id="L1107">        SerialUtils.writeStroke(this.cyclicNumberAxisProduct.getAdvanceLineStroke(), stream);</span>
<span class="fc" id="L1108">    }</span>

    /**
     * Provides serialization support.
     *
     * @param stream  the input stream.
     *
     * @throws IOException  if there is an I/O error.
     * @throws ClassNotFoundException  if there is a classpath problem.
     */
    private void readObject(ObjectInputStream stream)
            throws IOException, ClassNotFoundException {
<span class="fc" id="L1120">        stream.defaultReadObject();</span>
<span class="fc" id="L1121">		this.cyclicNumberAxisProduct = (CyclicNumberAxisProduct) stream.readObject();</span>
<span class="fc" id="L1122">        cyclicNumberAxisProduct.setAdvanceLinePaint2(SerialUtils.readPaint(stream));</span>
<span class="fc" id="L1123">        cyclicNumberAxisProduct.setAdvanceLineStroke2(SerialUtils.readStroke(stream));</span>
<span class="fc" id="L1124">    }</span>


    /**
     * Tests the axis for equality with another object.
     *
     * @param obj  the object to test against.
     *
     * @return A boolean.
     */
    @Override
    public boolean equals(Object obj) {
<span class="pc bpc" id="L1136" title="1 of 2 branches missed.">        if (obj == this) {</span>
<span class="nc" id="L1137">            return true;</span>
        }
<span class="pc bpc" id="L1139" title="1 of 2 branches missed.">        if (!(obj instanceof CyclicNumberAxis)) {</span>
<span class="nc" id="L1140">            return false;</span>
        }
<span class="pc bpc" id="L1142" title="1 of 2 branches missed.">        if (!super.equals(obj)) {</span>
<span class="nc" id="L1143">            return false;</span>
        }
<span class="fc" id="L1145">        CyclicNumberAxis that = (CyclicNumberAxis) obj;</span>
<span class="fc bfc" id="L1146" title="All 2 branches covered.">        if (this.period != that.period) {</span>
<span class="fc" id="L1147">            return false;</span>
        }
<span class="fc bfc" id="L1149" title="All 2 branches covered.">        if (this.offset != that.offset) {</span>
<span class="fc" id="L1150">            return false;</span>
        }
<span class="fc" id="L1152">        if (!PaintUtils.equal(this.cyclicNumberAxisProduct.getAdvanceLinePaint(),</span>
<span class="fc bfc" id="L1153" title="All 2 branches covered.">                that.cyclicNumberAxisProduct.getAdvanceLinePaint())) {</span>
<span class="fc" id="L1154">            return false;</span>
        }
<span class="fc bfc" id="L1156" title="All 2 branches covered.">        if (!Objects.equals(this.cyclicNumberAxisProduct.getAdvanceLineStroke(), that.cyclicNumberAxisProduct.getAdvanceLineStroke())) {</span>
<span class="fc" id="L1157">            return false;</span>
        }
<span class="fc bfc" id="L1159" title="All 2 branches covered.">        if (this.advanceLineVisible != that.advanceLineVisible) {</span>
<span class="fc" id="L1160">            return false;</span>
        }
<span class="fc bfc" id="L1162" title="All 2 branches covered.">        if (this.boundMappedToLastCycle != that.boundMappedToLastCycle) {</span>
<span class="fc" id="L1163">            return false;</span>
        }
<span class="fc" id="L1165">        return true;</span>
    }

	public Object clone() throws java.lang.CloneNotSupportedException {
<span class="fc" id="L1169">		CyclicNumberAxis clone = (CyclicNumberAxis) super.clone();</span>
<span class="fc" id="L1170">		clone.cyclicNumberAxisProduct = (CyclicNumberAxisProduct) this.cyclicNumberAxisProduct.clone();</span>
<span class="fc" id="L1171">		return clone;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span>java (1) (14 May 2022 17:53:42)</div></body></html>